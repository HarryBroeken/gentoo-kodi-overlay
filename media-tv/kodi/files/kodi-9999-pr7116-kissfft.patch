diff --git a/Kodi.xcodeproj/project.pbxproj b/Kodi.xcodeproj/project.pbxproj
index 3a5d8d3..395c4ea 100644
--- a/Kodi.xcodeproj/project.pbxproj
+++ b/Kodi.xcodeproj/project.pbxproj
@@ -41,7 +41,6 @@
 		18968DC814155D7C005BA742 /* ApplicationOperations.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 18968DC614155D7C005BA742 /* ApplicationOperations.cpp */; };
 		18ACF84313596C9B00B67371 /* RecentlyAddedJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 18ACF84113596C9B00B67371 /* RecentlyAddedJob.cpp */; };
 		18B4A0021152BFA5001AF8A6 /* Addon.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 18B49FF11152BFA5001AF8A6 /* Addon.cpp */; };
-		18B4A0041152BFA5001AF8A6 /* fft.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 18B49FF91152BFA5001AF8A6 /* fft.cpp */; };
 		18B4A0051152BFA5001AF8A6 /* Scraper.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 18B49FFC1152BFA5001AF8A6 /* Scraper.cpp */; };
 		18B4A0061152BFA5001AF8A6 /* ScreenSaver.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 18B49FFE1152BFA5001AF8A6 /* ScreenSaver.cpp */; };
 		18B4A0071152BFA5001AF8A6 /* Visualisation.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 18B4A0001152BFA5001AF8A6 /* Visualisation.cpp */; };
@@ -988,6 +987,15 @@
 		DFBB431A178B5E6F006CC20A /* CompileInfo.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFBB4317178B5E6F006CC20A /* CompileInfo.cpp */; };
 		DFBB431B178B5E6F006CC20A /* CompileInfo.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFBB4317178B5E6F006CC20A /* CompileInfo.cpp */; };
 		DFBE805115F7D75700D7D102 /* SystemConfiguration.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DFBE803D15F7D72100D7D102 /* SystemConfiguration.framework */; };
+		DFC6F4B61AFF7CB10039A7FA /* kiss_fft.c in Sources */ = {isa = PBXBuildFile; fileRef = DFC6F4AF1AFF7CB10039A7FA /* kiss_fft.c */; };
+		DFC6F4B71AFF7CB10039A7FA /* kiss_fft.c in Sources */ = {isa = PBXBuildFile; fileRef = DFC6F4AF1AFF7CB10039A7FA /* kiss_fft.c */; };
+		DFC6F4B81AFF7CB10039A7FA /* kiss_fft.c in Sources */ = {isa = PBXBuildFile; fileRef = DFC6F4AF1AFF7CB10039A7FA /* kiss_fft.c */; };
+		DFC6F4B91AFF7CB10039A7FA /* kiss_fftr.c in Sources */ = {isa = PBXBuildFile; fileRef = DFC6F4B11AFF7CB10039A7FA /* kiss_fftr.c */; };
+		DFC6F4BA1AFF7CB10039A7FA /* kiss_fftr.c in Sources */ = {isa = PBXBuildFile; fileRef = DFC6F4B11AFF7CB10039A7FA /* kiss_fftr.c */; };
+		DFC6F4BB1AFF7CB10039A7FA /* kiss_fftr.c in Sources */ = {isa = PBXBuildFile; fileRef = DFC6F4B11AFF7CB10039A7FA /* kiss_fftr.c */; };
+		DFC6F4C11AFF7E300039A7FA /* rfft.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFC6F4BF1AFF7E300039A7FA /* rfft.cpp */; };
+		DFC6F4C21AFF7E300039A7FA /* rfft.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFC6F4BF1AFF7E300039A7FA /* rfft.cpp */; };
+		DFC6F4C31AFF7E300039A7FA /* rfft.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFC6F4BF1AFF7E300039A7FA /* rfft.cpp */; };
 		DFCA6AC7152245CD000BFAAE /* HTTPJsonRpcHandler.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFCA6ABB152245CD000BFAAE /* HTTPJsonRpcHandler.cpp */; };
 		DFCA6AC8152245CD000BFAAE /* HTTPVfsHandler.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFCA6ABD152245CD000BFAAE /* HTTPVfsHandler.cpp */; };
 		DFCA6AC9152245CD000BFAAE /* HTTPWebinterfaceAddonsHandler.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFCA6ABF152245CD000BFAAE /* HTTPWebinterfaceAddonsHandler.cpp */; };
@@ -1687,7 +1695,6 @@
 		DFF0F3C717528350002DA3A4 /* DatabaseUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 36A9443B15821E2800727135 /* DatabaseUtils.cpp */; };
 		DFF0F3CB17528350002DA3A4 /* Environment.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF529BAC1741697B00523FB4 /* Environment.cpp */; };
 		DFF0F3CC17528350002DA3A4 /* Fanart.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E36C29E90DA72486001F0C9D /* Fanart.cpp */; };
-		DFF0F3CD17528350002DA3A4 /* fft.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 18B49FF91152BFA5001AF8A6 /* fft.cpp */; };
 		DFF0F3CE17528350002DA3A4 /* FileOperationJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = F5F244641110DC6B009126C6 /* FileOperationJob.cpp */; };
 		DFF0F3CF17528350002DA3A4 /* FileUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = F5F245EC1112C9AB009126C6 /* FileUtils.cpp */; };
 		DFF0F3D017528350002DA3A4 /* GLUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 18C1D22B13033F6A00CFFE59 /* GLUtils.cpp */; };
@@ -2870,7 +2877,6 @@
 		E499144B174E605900741B6D /* DatabaseUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 36A9443B15821E2800727135 /* DatabaseUtils.cpp */; };
 		E499144F174E605900741B6D /* Environment.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF529BAC1741697B00523FB4 /* Environment.cpp */; };
 		E4991450174E605900741B6D /* Fanart.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E36C29E90DA72486001F0C9D /* Fanart.cpp */; };
-		E4991451174E605900741B6D /* fft.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 18B49FF91152BFA5001AF8A6 /* fft.cpp */; };
 		E4991452174E605900741B6D /* FileOperationJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = F5F244641110DC6B009126C6 /* FileOperationJob.cpp */; };
 		E4991453174E605900741B6D /* FileUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = F5F245EC1112C9AB009126C6 /* FileUtils.cpp */; };
 		E4991454174E605900741B6D /* GLUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 18C1D22B13033F6A00CFFE59 /* GLUtils.cpp */; };
@@ -3248,8 +3254,6 @@
 		18B49FF41152BFA5001AF8A6 /* AddonManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = AddonManager.cpp; sourceTree = "<group>"; };
 		18B49FF51152BFA5001AF8A6 /* AddonManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AddonManager.h; sourceTree = "<group>"; };
 		18B49FF61152BFA5001AF8A6 /* DllAddon.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DllAddon.h; sourceTree = "<group>"; };
-		18B49FF91152BFA5001AF8A6 /* fft.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = fft.cpp; sourceTree = "<group>"; };
-		18B49FFA1152BFA5001AF8A6 /* fft.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fft.h; sourceTree = "<group>"; };
 		18B49FFB1152BFA5001AF8A6 /* IAddon.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = IAddon.h; sourceTree = "<group>"; };
 		18B49FFC1152BFA5001AF8A6 /* Scraper.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Scraper.cpp; sourceTree = "<group>"; };
 		18B49FFD1152BFA5001AF8A6 /* Scraper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Scraper.h; sourceTree = "<group>"; };
@@ -4606,6 +4610,13 @@
 		DFBB4317178B5E6F006CC20A /* CompileInfo.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CompileInfo.cpp; sourceTree = "<group>"; };
 		DFBB4318178B5E6F006CC20A /* CompileInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CompileInfo.h; sourceTree = "<group>"; };
 		DFBE803D15F7D72100D7D102 /* SystemConfiguration.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = SystemConfiguration.framework; path = System/Library/Frameworks/SystemConfiguration.framework; sourceTree = SDKROOT; };
+		DFC6F4AD1AFF7CB10039A7FA /* _kiss_fft_guts.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _kiss_fft_guts.h; sourceTree = "<group>"; };
+		DFC6F4AF1AFF7CB10039A7FA /* kiss_fft.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = kiss_fft.c; sourceTree = "<group>"; };
+		DFC6F4B01AFF7CB10039A7FA /* kiss_fft.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = kiss_fft.h; sourceTree = "<group>"; };
+		DFC6F4B11AFF7CB10039A7FA /* kiss_fftr.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = kiss_fftr.c; sourceTree = "<group>"; };
+		DFC6F4B21AFF7CB10039A7FA /* kiss_fftr.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = kiss_fftr.h; sourceTree = "<group>"; };
+		DFC6F4BF1AFF7E300039A7FA /* rfft.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = rfft.cpp; sourceTree = "<group>"; };
+		DFC6F4C01AFF7E300039A7FA /* rfft.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = rfft.h; sourceTree = "<group>"; };
 		DFC8B7CC199C1EC100424777 /* TopShelf.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = TopShelf.png; sourceTree = "<group>"; };
 		DFC8B7CD199C2B3A00424777 /* KodiAppliance.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = KodiAppliance.h; sourceTree = "<group>"; };
 		DFC8B7CE199C2B3A00424777 /* KodiAppliance.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = KodiAppliance.mm; sourceTree = "<group>"; };
@@ -7930,6 +7941,26 @@
 			path = Utils;
 			sourceTree = "<group>";
 		};
+		DFC6F4AB1AFF7CB10039A7FA /* contrib */ = {
+			isa = PBXGroup;
+			children = (
+				DFC6F4AC1AFF7CB10039A7FA /* kissfft */,
+			);
+			path = contrib;
+			sourceTree = "<group>";
+		};
+		DFC6F4AC1AFF7CB10039A7FA /* kissfft */ = {
+			isa = PBXGroup;
+			children = (
+				DFC6F4AD1AFF7CB10039A7FA /* _kiss_fft_guts.h */,
+				DFC6F4AF1AFF7CB10039A7FA /* kiss_fft.c */,
+				DFC6F4B01AFF7CB10039A7FA /* kiss_fft.h */,
+				DFC6F4B11AFF7CB10039A7FA /* kiss_fftr.c */,
+				DFC6F4B21AFF7CB10039A7FA /* kiss_fftr.h */,
+			);
+			path = kissfft;
+			sourceTree = "<group>";
+		};
 		DFCA6AB8152245CD000BFAAE /* httprequesthandler */ = {
 			isa = PBXGroup;
 			children = (
@@ -8113,6 +8144,7 @@
 		E38E14610D25F9F900618676 /* xbmc */ = {
 			isa = PBXGroup;
 			children = (
+				DFC6F4AB1AFF7CB10039A7FA /* contrib */,
 				18B49FF01152BEEB001AF8A6 /* addons */,
 				E38E147F0D25F9F900618676 /* cdrip */,
 				EC720A91155091CA00FFD782 /* commons */,
@@ -9172,8 +9204,6 @@
 				6E97BDC30DA2B620003A2A89 /* Fanart.h */,
 				F5E5697210803FC3006E788A /* fastmemcpy.c */,
 				43BF09DD1080D39300E25290 /* fastmemcpy.h */,
-				18B49FF91152BFA5001AF8A6 /* fft.cpp */,
-				18B49FFA1152BFA5001AF8A6 /* fft.h */,
 				F5F244641110DC6B009126C6 /* FileOperationJob.cpp */,
 				F5F244631110DC6B009126C6 /* FileOperationJob.h */,
 				F5F245EC1112C9AB009126C6 /* FileUtils.cpp */,
@@ -9236,6 +9266,8 @@
 				18ACF84213596C9B00B67371 /* RecentlyAddedJob.h */,
 				E38E1E730D25F9FD00618676 /* RegExp.cpp */,
 				E38E1E740D25F9FD00618676 /* RegExp.h */,
+				DFC6F4BF1AFF7E300039A7FA /* rfft.cpp */,
+				DFC6F4C01AFF7E300039A7FA /* rfft.h */,
 				F5DC87E1110A287400EE1B15 /* RingBuffer.cpp */,
 				F5DC87E0110A287400EE1B15 /* RingBuffer.h */,
 				DFAF6A4D16EBAE3800D6AE12 /* RssManager.cpp */,
@@ -10261,6 +10293,7 @@
 				E38E20B80D25F9FD00618676 /* GUIWindowMusicPlaylistEditor.cpp in Sources */,
 				E38E20B90D25F9FD00618676 /* GUIWindowMusicSongs.cpp in Sources */,
 				E38E20BB0D25F9FD00618676 /* GUIDialogVideoOSD.cpp in Sources */,
+				DFC6F4B91AFF7CB10039A7FA /* kiss_fftr.c in Sources */,
 				E38E20BC0D25F9FD00618676 /* GUIWindowPictures.cpp in Sources */,
 				E38E20BD0D25F9FD00618676 /* GUIWindowPointer.cpp in Sources */,
 				E38E20BE0D25F9FD00618676 /* GUIWindowPrograms.cpp in Sources */,
@@ -10506,7 +10539,6 @@
 				F5A7B37E113AFB900059D6AA /* SFTPDirectory.cpp in Sources */,
 				F5A7B42C113CBB950059D6AA /* AddonsDirectory.cpp in Sources */,
 				18B4A0021152BFA5001AF8A6 /* Addon.cpp in Sources */,
-				18B4A0041152BFA5001AF8A6 /* fft.cpp in Sources */,
 				18B4A0051152BFA5001AF8A6 /* Scraper.cpp in Sources */,
 				18B4A0061152BFA5001AF8A6 /* ScreenSaver.cpp in Sources */,
 				18B4A0071152BFA5001AF8A6 /* Visualisation.cpp in Sources */,
@@ -10801,6 +10833,7 @@
 				C84828FA156CFD5E005A996F /* GUIEPGGridContainer.cpp in Sources */,
 				C84828FE156CFDC3005A996F /* GUIDialogExtendedProgressBar.cpp in Sources */,
 				C8482901156CFE4B005A996F /* Observer.cpp in Sources */,
+				DFC6F4C11AFF7E300039A7FA /* rfft.cpp in Sources */,
 				C8482904156CFED9005A996F /* DVDDemuxPVRClient.cpp in Sources */,
 				C8482909156CFF24005A996F /* PVRDirectory.cpp in Sources */,
 				C848290A156CFF24005A996F /* PVRFile.cpp in Sources */,
@@ -10821,6 +10854,7 @@
 				36A9466315CF1FA600727135 /* DbUrl.cpp in Sources */,
 				3994427F1A8DD96F006C39E9 /* VideoLibraryQueue.cpp in Sources */,
 				36A9466715CF1FD200727135 /* MusicDbUrl.cpp in Sources */,
+				DFC6F4B61AFF7CB10039A7FA /* kiss_fft.c in Sources */,
 				36A9466A15CF1FED00727135 /* UrlOptions.cpp in Sources */,
 				36A9466D15CF201F00727135 /* VideoDbUrl.cpp in Sources */,
 				552A226915F7E14B0015C0D0 /* main.cpp in Sources */,
@@ -11794,7 +11828,6 @@
 				DFF0F3C717528350002DA3A4 /* DatabaseUtils.cpp in Sources */,
 				DFF0F3CB17528350002DA3A4 /* Environment.cpp in Sources */,
 				DFF0F3CC17528350002DA3A4 /* Fanart.cpp in Sources */,
-				DFF0F3CD17528350002DA3A4 /* fft.cpp in Sources */,
 				DFF0F3CE17528350002DA3A4 /* FileOperationJob.cpp in Sources */,
 				DFF0F3CF17528350002DA3A4 /* FileUtils.cpp in Sources */,
 				DFF0F3D017528350002DA3A4 /* GLUtils.cpp in Sources */,
@@ -11937,6 +11970,7 @@
 				DFF0F45C17528350002DA3A4 /* Dialog.cpp in Sources */,
 				DFF0F45D17528350002DA3A4 /* File.cpp in Sources */,
 				2F4564D71970129A00396109 /* GUIFontCache.cpp in Sources */,
+				DFC6F4B81AFF7CB10039A7FA /* kiss_fft.c in Sources */,
 				DFF0F45E17528350002DA3A4 /* InfoTagMusic.cpp in Sources */,
 				DFF0F45F17528350002DA3A4 /* InfoTagVideo.cpp in Sources */,
 				DFF0F46017528350002DA3A4 /* Keyboard.cpp in Sources */,
@@ -12108,11 +12142,13 @@
 				7CCDA850192756250074CF51 /* NptTls.cpp in Sources */,
 				7CCDA853192756250074CF51 /* NptUri.cpp in Sources */,
 				7CCDA85C192756250074CF51 /* NptUtils.cpp in Sources */,
+				DFC6F4C31AFF7E300039A7FA /* rfft.cpp in Sources */,
 				7CCDA865192756250074CF51 /* NptXml.cpp in Sources */,
 				7CCDA86E192756250074CF51 /* NptZip.cpp in Sources */,
 				7CCDAA84192756250074CF51 /* NptPosixDynamicLibraries.cpp in Sources */,
 				7CCDAA87192756250074CF51 /* NptPosixEnvironment.cpp in Sources */,
 				7CCDAA8D192756250074CF51 /* NptPosixNetwork.cpp in Sources */,
+				DFC6F4BB1AFF7CB10039A7FA /* kiss_fftr.c in Sources */,
 				7CCDAA90192756250074CF51 /* NptPosixQueue.cpp in Sources */,
 				7CCDAA99192756250074CF51 /* NptPosixSystem.cpp in Sources */,
 				7CCDAAA2192756250074CF51 /* NptPosixThreads.cpp in Sources */,
@@ -12237,6 +12273,7 @@
 				DF4BF0171A4EF31E0053AC56 /* cc_decoder.c in Sources */,
 				E49911BA174E5D0A00741B6D /* dll_tracker_library.cpp in Sources */,
 				E49911BB174E5D0A00741B6D /* dll_util.cpp in Sources */,
+				DFC6F4BA1AFF7CB10039A7FA /* kiss_fftr.c in Sources */,
 				E49911BC174E5D0A00741B6D /* DllLoader.cpp in Sources */,
 				E49911BD174E5D0A00741B6D /* DllLoaderContainer.cpp in Sources */,
 				E49911BE174E5D0A00741B6D /* LibraryLoader.cpp in Sources */,
@@ -12392,6 +12429,7 @@
 				E499126D174E5D8F00741B6D /* HDHomeRunFile.cpp in Sources */,
 				E4991270174E5D8F00741B6D /* HTTPDirectory.cpp in Sources */,
 				E4991271174E5D8F00741B6D /* HTTPFile.cpp in Sources */,
+				DFC6F4C21AFF7E300039A7FA /* rfft.cpp in Sources */,
 				E4991272174E5D8F00741B6D /* IDirectory.cpp in Sources */,
 				E4991273174E5D8F00741B6D /* IFile.cpp in Sources */,
 				E4991274174E5D8F00741B6D /* ImageFile.cpp in Sources */,
@@ -12586,6 +12624,7 @@
 				E499132E174E5DAD00741B6D /* TextureManager.cpp in Sources */,
 				E499132F174E5DAD00741B6D /* VisibleEffect.cpp in Sources */,
 				E4991330174E5DAD00741B6D /* XBTF.cpp in Sources */,
+				DFC6F4B71AFF7CB10039A7FA /* kiss_fft.c in Sources */,
 				E4991331174E5DAD00741B6D /* XBTFReader.cpp in Sources */,
 				E4991345174E5E5C00741B6D /* GenericTouchActionHandler.cpp in Sources */,
 				E499134B174E5E5C00741B6D /* ITouchInputHandling.cpp in Sources */,
@@ -12833,7 +12872,6 @@
 				E499144B174E605900741B6D /* DatabaseUtils.cpp in Sources */,
 				E499144F174E605900741B6D /* Environment.cpp in Sources */,
 				E4991450174E605900741B6D /* Fanart.cpp in Sources */,
-				E4991451174E605900741B6D /* fft.cpp in Sources */,
 				E4991452174E605900741B6D /* FileOperationJob.cpp in Sources */,
 				E4991453174E605900741B6D /* FileUtils.cpp in Sources */,
 				E4991454174E605900741B6D /* GLUtils.cpp in Sources */,
diff --git a/Makefile.in b/Makefile.in
index 7ed7c37..0317567 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -30,6 +30,7 @@ DIRECTORY_ARCHIVES=$(DVDPLAYER_ARCHIVES) \
                    lib/SlingboxLib/SlingboxLib.a \
                    xbmc/addons/addons.a \
                    xbmc/cdrip/cdrip.a \
+                   xbmc/contrib/kissfft/kissfft.a \
                    xbmc/cores/AudioEngine/audioengine.a \
                    xbmc/cores/DllLoader/dllloader.a \
                    xbmc/cores/DllLoader/exports/exports.a \
diff --git a/project/VS2010Express/XBMC.vcxproj b/project/VS2010Express/XBMC.vcxproj
index cb64dd5..fe85f46 100644
--- a/project/VS2010Express/XBMC.vcxproj
+++ b/project/VS2010Express/XBMC.vcxproj
@@ -200,6 +200,14 @@
     <ClCompile Include="..\..\xbmc\BackgroundInfoLoader.cpp" />
     <ClCompile Include="..\..\xbmc\CompileInfo.cpp" />
     <ClCompile Include="..\..\xbmc\ContextMenuManager.cpp" />
+    <ClCompile Include="..\..\xbmc\contrib\kissfft\kiss_fft.c">
+      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">CompileAsCpp</CompileAs>
+      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">CompileAsCpp</CompileAs>
+    </ClCompile>
+    <ClCompile Include="..\..\xbmc\contrib\kissfft\kiss_fftr.c">
+      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">CompileAsCpp</CompileAs>
+      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">CompileAsCpp</CompileAs>
+    </ClCompile>
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\AEFactory.cpp" />
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\AEResampleFactory.cpp" />
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\AESinkFactory.cpp" />
@@ -826,6 +834,9 @@
     <ClInclude Include="..\..\xbmc\ApplicationPlayer.h" />
     <ClInclude Include="..\..\xbmc\AppParamParser.h" />
     <ClInclude Include="..\..\xbmc\CompileInfo.h" />
+    <ClInclude Include="..\..\xbmc\contrib\kissfft\kiss_fft.h" />
+    <ClInclude Include="..\..\xbmc\contrib\kissfft\kiss_fftr.h" />
+    <ClInclude Include="..\..\xbmc\contrib\kissfft\_kiss_fft_guts.h" />
     <ClInclude Include="..\..\xbmc\cores\DataCacheCore.h" />
     <ClInclude Include="..\..\xbmc\cores\AudioEngine\AEFactory.h" />
     <ClInclude Include="..\..\xbmc\cores\AudioEngine\AEResampleFactory.h" />
@@ -1024,6 +1035,7 @@
     <ClInclude Include="..\..\xbmc\utils\Locale.h" />
     <ClInclude Include="..\..\xbmc\utils\params_check_macros.h" />
     <ClInclude Include="..\..\xbmc\utils\ProgressJob.h" />
+    <ClInclude Include="..\..\xbmc\utils\rfft.h" />
     <ClInclude Include="..\..\xbmc\utils\RssManager.h" />
     <ClInclude Include="..\..\xbmc\utils\Speed.h" />
     <ClInclude Include="..\..\xbmc\utils\StringValidation.h" />
@@ -1147,6 +1159,7 @@
     <ClCompile Include="..\..\xbmc\utils\LegacyPathTranslation.cpp" />
     <ClCompile Include="..\..\xbmc\utils\Locale.cpp" />
     <ClCompile Include="..\..\xbmc\utils\ProgressJob.cpp" />
+    <ClCompile Include="..\..\xbmc\utils\rfft.cpp" />
     <ClCompile Include="..\..\xbmc\utils\RssManager.cpp" />
     <ClCompile Include="..\..\xbmc\utils\Speed.cpp" />
     <ClCompile Include="..\..\xbmc\utils\StringValidation.cpp" />
@@ -1159,6 +1172,10 @@
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
     </ClCompile>
+    <ClCompile Include="..\..\xbmc\utils\test\Testrfft.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+    </ClCompile>
     <ClCompile Include="..\..\xbmc\utils\test\TestUrlOptions.cpp">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
@@ -1195,7 +1212,6 @@
     <ClCompile Include="..\..\xbmc\utils\DatabaseUtils.cpp" />
     <ClCompile Include="..\..\xbmc\utils\EndianSwap.cpp" />
     <ClCompile Include="..\..\xbmc\utils\Fanart.cpp" />
-    <ClCompile Include="..\..\xbmc\utils\fft.cpp" />
     <ClCompile Include="..\..\xbmc\utils\FileOperationJob.cpp" />
     <ClCompile Include="..\..\xbmc\utils\FileUtils.cpp" />
     <ClCompile Include="..\..\xbmc\utils\fstrcmp.c">
@@ -1425,10 +1441,6 @@
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
     </ClCompile>
-    <ClCompile Include="..\..\xbmc\utils\test\Testfft.cpp">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </ClCompile>
     <ClCompile Include="..\..\xbmc\utils\TimeSmoother.cpp" />
     <ClCompile Include="..\..\xbmc\utils\TimeUtils.cpp" />
     <ClCompile Include="..\..\xbmc\utils\URIUtils.cpp" />
@@ -2053,7 +2065,6 @@
     <ClInclude Include="..\..\xbmc\utils\DatabaseUtils.h" />
     <ClInclude Include="..\..\xbmc\utils\EndianSwap.h" />
     <ClInclude Include="..\..\xbmc\utils\Fanart.h" />
-    <ClInclude Include="..\..\xbmc\utils\fft.h" />
     <ClInclude Include="..\..\xbmc\utils\FileOperationJob.h" />
     <ClInclude Include="..\..\xbmc\utils\FileUtils.h" />
     <ClInclude Include="..\..\xbmc\utils\fstrcmp.h" />
diff --git a/project/VS2010Express/XBMC.vcxproj.filters b/project/VS2010Express/XBMC.vcxproj.filters
index 741d3d4..c858f32 100644
--- a/project/VS2010Express/XBMC.vcxproj.filters
+++ b/project/VS2010Express/XBMC.vcxproj.filters
@@ -334,6 +334,12 @@
     <Filter Include="interfaces\legacy\wsgi">
       <UniqueIdentifier>{4750236a-887e-40c1-af3e-1e095f5960e0}</UniqueIdentifier>
     </Filter>
+    <Filter Include="contrib">
+      <UniqueIdentifier>{9c3139a5-4a8a-4533-af30-cd79ee250997}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="contrib\kissfft">
+      <UniqueIdentifier>{d811b1d1-5e81-4d89-9173-f02818c897ab}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
   <ItemGroup>
     <ClCompile Include="..\..\xbmc\win32\pch.cpp">
@@ -1387,9 +1393,6 @@
     <ClCompile Include="..\..\xbmc\utils\Fanart.cpp">
       <Filter>utils</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\xbmc\utils\fft.cpp">
-      <Filter>utils</Filter>
-    </ClCompile>
     <ClCompile Include="..\..\xbmc\utils\FileOperationJob.cpp">
       <Filter>utils</Filter>
     </ClCompile>
@@ -2371,9 +2374,6 @@
     <ClCompile Include="..\..\xbmc\utils\test\Testfastmemcpy.cpp">
       <Filter>utils\test</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\xbmc\utils\test\Testfft.cpp">
-      <Filter>utils\test</Filter>
-    </ClCompile>
     <ClCompile Include="..\..\xbmc\utils\test\TestFileOperationJob.cpp">
       <Filter>utils\test</Filter>
     </ClCompile>
@@ -3087,6 +3087,18 @@
     <ClCompile Include="..\..\xbmc\test\TestUtil.cpp">
       <Filter>test</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\xbmc\utils\rfft.cpp">
+      <Filter>utils</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\xbmc\utils\test\Testrfft.cpp">
+      <Filter>utils\test</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\xbmc\contrib\kissfft\kiss_fft.c">
+      <Filter>contrib\kissfft</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\xbmc\contrib\kissfft\kiss_fftr.c">
+      <Filter>contrib\kissfft</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\xbmc\win32\pch.h">
@@ -4297,9 +4309,6 @@
     <ClInclude Include="..\..\xbmc\utils\Fanart.h">
       <Filter>utils</Filter>
     </ClInclude>
-    <ClInclude Include="..\..\xbmc\utils\fft.h">
-      <Filter>utils</Filter>
-    </ClInclude>
     <ClInclude Include="..\..\xbmc\utils\FileOperationJob.h">
       <Filter>utils</Filter>
     </ClInclude>
@@ -5971,6 +5980,18 @@
     <ClInclude Include="..\..\xbmc\music\EmbeddedArt.h">
       <Filter>music</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\xbmc\utils\rfft.h">
+      <Filter>utils</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\xbmc\contrib\kissfft\_kiss_fft_guts.h">
+      <Filter>contrib\kissfft</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\xbmc\contrib\kissfft\kiss_fft.h">
+      <Filter>contrib\kissfft</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\xbmc\contrib\kissfft\kiss_fftr.h">
+      <Filter>contrib\kissfft</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="..\..\xbmc\win32\XBMC_PC.rc">
diff --git a/xbmc/addons/Visualisation.cpp b/xbmc/addons/Visualisation.cpp
index a64ee59..122204a 100644
--- a/xbmc/addons/Visualisation.cpp
+++ b/xbmc/addons/Visualisation.cpp
@@ -19,7 +19,6 @@
  */
 #include "system.h"
 #include "Visualisation.h"
-#include "utils/fft.h"
 #include "GUIInfoManager.h"
 #include "Application.h"
 #include "guilib/GraphicContext.h"
@@ -278,21 +277,14 @@ void CVisualisation::OnAudioData(const float* pAudioData, int iAudioDataLength)
   if (m_bWantsFreq)
   {
     const float *psAudioData = ptrAudioBuffer->Get();
-    memcpy(m_fFreq, psAudioData, AUDIO_BUFFER_SIZE * sizeof(float));
 
-    // FFT the data
-    twochanwithwindow(m_fFreq, AUDIO_BUFFER_SIZE);
+    if (!m_transform)
+      m_transform.reset(new RFFT(AUDIO_BUFFER_SIZE/2, false)); // half due to stereo
 
-    // Normalize the data
-    float fMinData = (float)AUDIO_BUFFER_SIZE * AUDIO_BUFFER_SIZE * 3 / 8 * 0.5 * 0.5; // 3/8 for the Hann window, 0.5 as minimum amplitude
-    float fInvMinData = 1.0f/fMinData;
-    for (int i = 0; i < AUDIO_BUFFER_SIZE + 2; i++)
-    {
-      m_fFreq[i] *= fInvMinData;
-    }
+    m_transform->calc(psAudioData, m_fFreq);
 
     // Transfer data to our visualisation
-    AudioData(psAudioData, AUDIO_BUFFER_SIZE, m_fFreq, AUDIO_BUFFER_SIZE);
+    AudioData(psAudioData, AUDIO_BUFFER_SIZE, m_fFreq, AUDIO_BUFFER_SIZE/2); // half due to complex-conjugate
   }
   else
   { // Transfer data to our visualisation
@@ -327,7 +319,7 @@ void CVisualisation::ClearBuffers()
     delete pAudioBuffer;
     m_vecBuffers.pop_front();
   }
-  for (int j = 0; j < AUDIO_BUFFER_SIZE*2; j++)
+  for (int j = 0; j < AUDIO_BUFFER_SIZE; j++)
   {
     m_fFreq[j] = 0.0f;
   }
diff --git a/xbmc/addons/Visualisation.h b/xbmc/addons/Visualisation.h
index 0a2a1cb..e86e897 100644
--- a/xbmc/addons/Visualisation.h
+++ b/xbmc/addons/Visualisation.h
@@ -23,7 +23,9 @@
 #include "cores/IAudioCallback.h"
 #include "include/xbmc_vis_types.h"
 #include "guilib/IRenderingCallback.h"
+#include "utils/rfft.h"
 
+#include <algorithm>
 #include <map>
 #include <list>
 #include <memory>
@@ -102,8 +104,9 @@ namespace ADDON
     std::list<CAudioBuffer*> m_vecBuffers;
     int m_iNumBuffers;        // Number of Audio buffers
     bool m_bWantsFreq;
-    float m_fFreq[2*AUDIO_BUFFER_SIZE];         // Frequency data
+    float m_fFreq[AUDIO_BUFFER_SIZE];         // Frequency data
     bool m_bCalculate_Freq;       // True if the vis wants freq data
+    std::unique_ptr<RFFT> m_transform;
 
     // track information
     std::string m_AlbumThumb;
diff --git a/xbmc/contrib/kissfft/COPYING b/xbmc/contrib/kissfft/COPYING
new file mode 100644
index 0000000..2fc6685
--- /dev/null
+++ b/xbmc/contrib/kissfft/COPYING
@@ -0,0 +1,11 @@
+Copyright (c) 2003-2010 Mark Borgerding
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/xbmc/contrib/kissfft/Makefile b/xbmc/contrib/kissfft/Makefile
new file mode 100644
index 0000000..72672ee
--- /dev/null
+++ b/xbmc/contrib/kissfft/Makefile
@@ -0,0 +1,6 @@
+SRCS=kiss_fft.c kiss_fftr.c
+
+LIB=kissfft.a
+
+include ../../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff --git a/xbmc/contrib/kissfft/_kiss_fft_guts.h b/xbmc/contrib/kissfft/_kiss_fft_guts.h
new file mode 100644
index 0000000..ba66144
--- /dev/null
+++ b/xbmc/contrib/kissfft/_kiss_fft_guts.h
@@ -0,0 +1,164 @@
+/*
+Copyright (c) 2003-2010, Mark Borgerding
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/* kiss_fft.h
+   defines kiss_fft_scalar as either short or a float type
+   and defines
+   typedef struct { kiss_fft_scalar r; kiss_fft_scalar i; }kiss_fft_cpx; */
+#include "kiss_fft.h"
+#include <limits.h>
+
+#define MAXFACTORS 32
+/* e.g. an fft of length 128 has 4 factors 
+ as far as kissfft is concerned
+ 4*4*4*2
+ */
+
+struct kiss_fft_state{
+    int nfft;
+    int inverse;
+    int factors[2*MAXFACTORS];
+    kiss_fft_cpx twiddles[1];
+};
+
+/*
+  Explanation of macros dealing with complex math:
+
+   C_MUL(m,a,b)         : m = a*b
+   C_FIXDIV( c , div )  : if a fixed point impl., c /= div. noop otherwise
+   C_SUB( res, a,b)     : res = a - b
+   C_SUBFROM( res , a)  : res -= a
+   C_ADDTO( res , a)    : res += a
+ * */
+#ifdef FIXED_POINT
+#if (FIXED_POINT==32)
+# define FRACBITS 31
+# define SAMPPROD int64_t
+#define SAMP_MAX 2147483647
+#else
+# define FRACBITS 15
+# define SAMPPROD int32_t 
+#define SAMP_MAX 32767
+#endif
+
+#define SAMP_MIN -SAMP_MAX
+
+#if defined(CHECK_OVERFLOW)
+#  define CHECK_OVERFLOW_OP(a,op,b)  \
+	if ( (SAMPPROD)(a) op (SAMPPROD)(b) > SAMP_MAX || (SAMPPROD)(a) op (SAMPPROD)(b) < SAMP_MIN ) { \
+		fprintf(stderr,"WARNING:overflow @ " __FILE__ "(%d): (%d " #op" %d) = %ld\n",__LINE__,(a),(b),(SAMPPROD)(a) op (SAMPPROD)(b) );  }
+#endif
+
+
+#   define smul(a,b) ( (SAMPPROD)(a)*(b) )
+#   define sround( x )  (kiss_fft_scalar)( ( (x) + (1<<(FRACBITS-1)) ) >> FRACBITS )
+
+#   define S_MUL(a,b) sround( smul(a,b) )
+
+#   define C_MUL(m,a,b) \
+      do{ (m).r = sround( smul((a).r,(b).r) - smul((a).i,(b).i) ); \
+          (m).i = sround( smul((a).r,(b).i) + smul((a).i,(b).r) ); }while(0)
+
+#   define DIVSCALAR(x,k) \
+	(x) = sround( smul(  x, SAMP_MAX/k ) )
+
+#   define C_FIXDIV(c,div) \
+	do {    DIVSCALAR( (c).r , div);  \
+		DIVSCALAR( (c).i  , div); }while (0)
+
+#   define C_MULBYSCALAR( c, s ) \
+    do{ (c).r =  sround( smul( (c).r , s ) ) ;\
+        (c).i =  sround( smul( (c).i , s ) ) ; }while(0)
+
+#else  /* not FIXED_POINT*/
+
+#   define S_MUL(a,b) ( (a)*(b) )
+#define C_MUL(m,a,b) \
+    do{ (m).r = (a).r*(b).r - (a).i*(b).i;\
+        (m).i = (a).r*(b).i + (a).i*(b).r; }while(0)
+#   define C_FIXDIV(c,div) /* NOOP */
+#   define C_MULBYSCALAR( c, s ) \
+    do{ (c).r *= (s);\
+        (c).i *= (s); }while(0)
+#endif
+
+#ifndef CHECK_OVERFLOW_OP
+#  define CHECK_OVERFLOW_OP(a,op,b) /* noop */
+#endif
+
+#define  C_ADD( res, a,b)\
+    do { \
+	    CHECK_OVERFLOW_OP((a).r,+,(b).r)\
+	    CHECK_OVERFLOW_OP((a).i,+,(b).i)\
+	    (res).r=(a).r+(b).r;  (res).i=(a).i+(b).i; \
+    }while(0)
+#define  C_SUB( res, a,b)\
+    do { \
+	    CHECK_OVERFLOW_OP((a).r,-,(b).r)\
+	    CHECK_OVERFLOW_OP((a).i,-,(b).i)\
+	    (res).r=(a).r-(b).r;  (res).i=(a).i-(b).i; \
+    }while(0)
+#define C_ADDTO( res , a)\
+    do { \
+	    CHECK_OVERFLOW_OP((res).r,+,(a).r)\
+	    CHECK_OVERFLOW_OP((res).i,+,(a).i)\
+	    (res).r += (a).r;  (res).i += (a).i;\
+    }while(0)
+
+#define C_SUBFROM( res , a)\
+    do {\
+	    CHECK_OVERFLOW_OP((res).r,-,(a).r)\
+	    CHECK_OVERFLOW_OP((res).i,-,(a).i)\
+	    (res).r -= (a).r;  (res).i -= (a).i; \
+    }while(0)
+
+
+#ifdef FIXED_POINT
+#  define KISS_FFT_COS(phase)  floor(.5+SAMP_MAX * cos (phase))
+#  define KISS_FFT_SIN(phase)  floor(.5+SAMP_MAX * sin (phase))
+#  define HALF_OF(x) ((x)>>1)
+#elif defined(USE_SIMD)
+#  define KISS_FFT_COS(phase) _mm_set1_ps( cos(phase) )
+#  define KISS_FFT_SIN(phase) _mm_set1_ps( sin(phase) )
+#  define HALF_OF(x) ((x)*_mm_set1_ps(.5))
+#else
+#  define KISS_FFT_COS(phase) (kiss_fft_scalar) cos(phase)
+#  define KISS_FFT_SIN(phase) (kiss_fft_scalar) sin(phase)
+#  define HALF_OF(x) ((x)*.5)
+#endif
+
+#define  kf_cexp(x,phase) \
+	do{ \
+		(x)->r = KISS_FFT_COS(phase);\
+		(x)->i = KISS_FFT_SIN(phase);\
+	}while(0)
+
+
+/* a debugging function */
+#define pcpx(c)\
+    fprintf(stderr,"%g + %gi\n",(double)((c)->r),(double)((c)->i) )
+
+
+#ifdef KISS_FFT_USE_ALLOCA
+// define this to allow use of alloca instead of malloc for temporary buffers
+// Temporary buffers are used in two case: 
+// 1. FFT sizes that have "bad" factors. i.e. not 2,3 and 5
+// 2. "in-place" FFTs.  Notice the quotes, since kissfft does not really do an in-place transform.
+#include <alloca.h>
+#define  KISS_FFT_TMP_ALLOC(nbytes) alloca(nbytes)
+#define  KISS_FFT_TMP_FREE(ptr) 
+#else
+#define  KISS_FFT_TMP_ALLOC(nbytes) KISS_FFT_MALLOC(nbytes)
+#define  KISS_FFT_TMP_FREE(ptr) KISS_FFT_FREE(ptr)
+#endif
diff --git a/xbmc/contrib/kissfft/kiss_fft.c b/xbmc/contrib/kissfft/kiss_fft.c
new file mode 100644
index 0000000..465d6c9
--- /dev/null
+++ b/xbmc/contrib/kissfft/kiss_fft.c
@@ -0,0 +1,408 @@
+/*
+Copyright (c) 2003-2010, Mark Borgerding
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#include "_kiss_fft_guts.h"
+/* The guts header contains all the multiplication and addition macros that are defined for
+ fixed or floating point complex numbers.  It also delares the kf_ internal functions.
+ */
+
+static void kf_bfly2(
+        kiss_fft_cpx * Fout,
+        const size_t fstride,
+        const kiss_fft_cfg st,
+        int m
+        )
+{
+    kiss_fft_cpx * Fout2;
+    kiss_fft_cpx * tw1 = st->twiddles;
+    kiss_fft_cpx t;
+    Fout2 = Fout + m;
+    do{
+        C_FIXDIV(*Fout,2); C_FIXDIV(*Fout2,2);
+
+        C_MUL (t,  *Fout2 , *tw1);
+        tw1 += fstride;
+        C_SUB( *Fout2 ,  *Fout , t );
+        C_ADDTO( *Fout ,  t );
+        ++Fout2;
+        ++Fout;
+    }while (--m);
+}
+
+static void kf_bfly4(
+        kiss_fft_cpx * Fout,
+        const size_t fstride,
+        const kiss_fft_cfg st,
+        const size_t m
+        )
+{
+    kiss_fft_cpx *tw1,*tw2,*tw3;
+    kiss_fft_cpx scratch[6];
+    size_t k=m;
+    const size_t m2=2*m;
+    const size_t m3=3*m;
+
+
+    tw3 = tw2 = tw1 = st->twiddles;
+
+    do {
+        C_FIXDIV(*Fout,4); C_FIXDIV(Fout[m],4); C_FIXDIV(Fout[m2],4); C_FIXDIV(Fout[m3],4);
+
+        C_MUL(scratch[0],Fout[m] , *tw1 );
+        C_MUL(scratch[1],Fout[m2] , *tw2 );
+        C_MUL(scratch[2],Fout[m3] , *tw3 );
+
+        C_SUB( scratch[5] , *Fout, scratch[1] );
+        C_ADDTO(*Fout, scratch[1]);
+        C_ADD( scratch[3] , scratch[0] , scratch[2] );
+        C_SUB( scratch[4] , scratch[0] , scratch[2] );
+        C_SUB( Fout[m2], *Fout, scratch[3] );
+        tw1 += fstride;
+        tw2 += fstride*2;
+        tw3 += fstride*3;
+        C_ADDTO( *Fout , scratch[3] );
+
+        if(st->inverse) {
+            Fout[m].r = scratch[5].r - scratch[4].i;
+            Fout[m].i = scratch[5].i + scratch[4].r;
+            Fout[m3].r = scratch[5].r + scratch[4].i;
+            Fout[m3].i = scratch[5].i - scratch[4].r;
+        }else{
+            Fout[m].r = scratch[5].r + scratch[4].i;
+            Fout[m].i = scratch[5].i - scratch[4].r;
+            Fout[m3].r = scratch[5].r - scratch[4].i;
+            Fout[m3].i = scratch[5].i + scratch[4].r;
+        }
+        ++Fout;
+    }while(--k);
+}
+
+static void kf_bfly3(
+         kiss_fft_cpx * Fout,
+         const size_t fstride,
+         const kiss_fft_cfg st,
+         size_t m
+         )
+{
+     size_t k=m;
+     const size_t m2 = 2*m;
+     kiss_fft_cpx *tw1,*tw2;
+     kiss_fft_cpx scratch[5];
+     kiss_fft_cpx epi3;
+     epi3 = st->twiddles[fstride*m];
+
+     tw1=tw2=st->twiddles;
+
+     do{
+         C_FIXDIV(*Fout,3); C_FIXDIV(Fout[m],3); C_FIXDIV(Fout[m2],3);
+
+         C_MUL(scratch[1],Fout[m] , *tw1);
+         C_MUL(scratch[2],Fout[m2] , *tw2);
+
+         C_ADD(scratch[3],scratch[1],scratch[2]);
+         C_SUB(scratch[0],scratch[1],scratch[2]);
+         tw1 += fstride;
+         tw2 += fstride*2;
+
+         Fout[m].r = Fout->r - HALF_OF(scratch[3].r);
+         Fout[m].i = Fout->i - HALF_OF(scratch[3].i);
+
+         C_MULBYSCALAR( scratch[0] , epi3.i );
+
+         C_ADDTO(*Fout,scratch[3]);
+
+         Fout[m2].r = Fout[m].r + scratch[0].i;
+         Fout[m2].i = Fout[m].i - scratch[0].r;
+
+         Fout[m].r -= scratch[0].i;
+         Fout[m].i += scratch[0].r;
+
+         ++Fout;
+     }while(--k);
+}
+
+static void kf_bfly5(
+        kiss_fft_cpx * Fout,
+        const size_t fstride,
+        const kiss_fft_cfg st,
+        int m
+        )
+{
+    kiss_fft_cpx *Fout0,*Fout1,*Fout2,*Fout3,*Fout4;
+    int u;
+    kiss_fft_cpx scratch[13];
+    kiss_fft_cpx * twiddles = st->twiddles;
+    kiss_fft_cpx *tw;
+    kiss_fft_cpx ya,yb;
+    ya = twiddles[fstride*m];
+    yb = twiddles[fstride*2*m];
+
+    Fout0=Fout;
+    Fout1=Fout0+m;
+    Fout2=Fout0+2*m;
+    Fout3=Fout0+3*m;
+    Fout4=Fout0+4*m;
+
+    tw=st->twiddles;
+    for ( u=0; u<m; ++u ) {
+        C_FIXDIV( *Fout0,5); C_FIXDIV( *Fout1,5); C_FIXDIV( *Fout2,5); C_FIXDIV( *Fout3,5); C_FIXDIV( *Fout4,5);
+        scratch[0] = *Fout0;
+
+        C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
+        C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
+        C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
+        C_MUL(scratch[4] ,*Fout4, tw[4*u*fstride]);
+
+        C_ADD( scratch[7],scratch[1],scratch[4]);
+        C_SUB( scratch[10],scratch[1],scratch[4]);
+        C_ADD( scratch[8],scratch[2],scratch[3]);
+        C_SUB( scratch[9],scratch[2],scratch[3]);
+
+        Fout0->r += scratch[7].r + scratch[8].r;
+        Fout0->i += scratch[7].i + scratch[8].i;
+
+        scratch[5].r = scratch[0].r + S_MUL(scratch[7].r,ya.r) + S_MUL(scratch[8].r,yb.r);
+        scratch[5].i = scratch[0].i + S_MUL(scratch[7].i,ya.r) + S_MUL(scratch[8].i,yb.r);
+
+        scratch[6].r =  S_MUL(scratch[10].i,ya.i) + S_MUL(scratch[9].i,yb.i);
+        scratch[6].i = -S_MUL(scratch[10].r,ya.i) - S_MUL(scratch[9].r,yb.i);
+
+        C_SUB(*Fout1,scratch[5],scratch[6]);
+        C_ADD(*Fout4,scratch[5],scratch[6]);
+
+        scratch[11].r = scratch[0].r + S_MUL(scratch[7].r,yb.r) + S_MUL(scratch[8].r,ya.r);
+        scratch[11].i = scratch[0].i + S_MUL(scratch[7].i,yb.r) + S_MUL(scratch[8].i,ya.r);
+        scratch[12].r = - S_MUL(scratch[10].i,yb.i) + S_MUL(scratch[9].i,ya.i);
+        scratch[12].i = S_MUL(scratch[10].r,yb.i) - S_MUL(scratch[9].r,ya.i);
+
+        C_ADD(*Fout2,scratch[11],scratch[12]);
+        C_SUB(*Fout3,scratch[11],scratch[12]);
+
+        ++Fout0;++Fout1;++Fout2;++Fout3;++Fout4;
+    }
+}
+
+/* perform the butterfly for one stage of a mixed radix FFT */
+static void kf_bfly_generic(
+        kiss_fft_cpx * Fout,
+        const size_t fstride,
+        const kiss_fft_cfg st,
+        int m,
+        int p
+        )
+{
+    int u,k,q1,q;
+    kiss_fft_cpx * twiddles = st->twiddles;
+    kiss_fft_cpx t;
+    int Norig = st->nfft;
+
+    kiss_fft_cpx * scratch = (kiss_fft_cpx*)KISS_FFT_TMP_ALLOC(sizeof(kiss_fft_cpx)*p);
+
+    for ( u=0; u<m; ++u ) {
+        k=u;
+        for ( q1=0 ; q1<p ; ++q1 ) {
+            scratch[q1] = Fout[ k  ];
+            C_FIXDIV(scratch[q1],p);
+            k += m;
+        }
+
+        k=u;
+        for ( q1=0 ; q1<p ; ++q1 ) {
+            int twidx=0;
+            Fout[ k ] = scratch[0];
+            for (q=1;q<p;++q ) {
+                twidx += fstride * k;
+                if (twidx>=Norig) twidx-=Norig;
+                C_MUL(t,scratch[q] , twiddles[twidx] );
+                C_ADDTO( Fout[ k ] ,t);
+            }
+            k += m;
+        }
+    }
+    KISS_FFT_TMP_FREE(scratch);
+}
+
+static
+void kf_work(
+        kiss_fft_cpx * Fout,
+        const kiss_fft_cpx * f,
+        const size_t fstride,
+        int in_stride,
+        int * factors,
+        const kiss_fft_cfg st
+        )
+{
+    kiss_fft_cpx * Fout_beg=Fout;
+    const int p=*factors++; /* the radix  */
+    const int m=*factors++; /* stage's fft length/p */
+    const kiss_fft_cpx * Fout_end = Fout + p*m;
+
+#ifdef _OPENMP
+    // use openmp extensions at the 
+    // top-level (not recursive)
+    if (fstride==1 && p<=5)
+    {
+        int k;
+
+        // execute the p different work units in different threads
+#       pragma omp parallel for
+        for (k=0;k<p;++k) 
+            kf_work( Fout +k*m, f+ fstride*in_stride*k,fstride*p,in_stride,factors,st);
+        // all threads have joined by this point
+
+        switch (p) {
+            case 2: kf_bfly2(Fout,fstride,st,m); break;
+            case 3: kf_bfly3(Fout,fstride,st,m); break; 
+            case 4: kf_bfly4(Fout,fstride,st,m); break;
+            case 5: kf_bfly5(Fout,fstride,st,m); break; 
+            default: kf_bfly_generic(Fout,fstride,st,m,p); break;
+        }
+        return;
+    }
+#endif
+
+    if (m==1) {
+        do{
+            *Fout = *f;
+            f += fstride*in_stride;
+        }while(++Fout != Fout_end );
+    }else{
+        do{
+            // recursive call:
+            // DFT of size m*p performed by doing
+            // p instances of smaller DFTs of size m, 
+            // each one takes a decimated version of the input
+            kf_work( Fout , f, fstride*p, in_stride, factors,st);
+            f += fstride*in_stride;
+        }while( (Fout += m) != Fout_end );
+    }
+
+    Fout=Fout_beg;
+
+    // recombine the p smaller DFTs 
+    switch (p) {
+        case 2: kf_bfly2(Fout,fstride,st,m); break;
+        case 3: kf_bfly3(Fout,fstride,st,m); break; 
+        case 4: kf_bfly4(Fout,fstride,st,m); break;
+        case 5: kf_bfly5(Fout,fstride,st,m); break; 
+        default: kf_bfly_generic(Fout,fstride,st,m,p); break;
+    }
+}
+
+/*  facbuf is populated by p1,m1,p2,m2, ...
+    where 
+    p[i] * m[i] = m[i-1]
+    m0 = n                  */
+static 
+void kf_factor(int n,int * facbuf)
+{
+    int p=4;
+    double floor_sqrt;
+    floor_sqrt = floor( sqrt((double)n) );
+
+    /*factor out powers of 4, powers of 2, then any remaining primes */
+    do {
+        while (n % p) {
+            switch (p) {
+                case 4: p = 2; break;
+                case 2: p = 3; break;
+                default: p += 2; break;
+            }
+            if (p > floor_sqrt)
+                p = n;          /* no more factors, skip to end */
+        }
+        n /= p;
+        *facbuf++ = p;
+        *facbuf++ = n;
+    } while (n > 1);
+}
+
+/*
+ *
+ * User-callable function to allocate all necessary storage space for the fft.
+ *
+ * The return value is a contiguous block of memory, allocated with malloc.  As such,
+ * It can be freed with free(), rather than a kiss_fft-specific function.
+ * */
+kiss_fft_cfg kiss_fft_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem )
+{
+    kiss_fft_cfg st=NULL;
+    size_t memneeded = sizeof(struct kiss_fft_state)
+        + sizeof(kiss_fft_cpx)*(nfft-1); /* twiddle factors*/
+
+    if ( lenmem==NULL ) {
+        st = ( kiss_fft_cfg)KISS_FFT_MALLOC( memneeded );
+    }else{
+        if (mem != NULL && *lenmem >= memneeded)
+            st = (kiss_fft_cfg)mem;
+        *lenmem = memneeded;
+    }
+    if (st) {
+        int i;
+        st->nfft=nfft;
+        st->inverse = inverse_fft;
+
+        for (i=0;i<nfft;++i) {
+            const double pi=3.141592653589793238462643383279502884197169399375105820974944;
+            double phase = -2*pi*i / nfft;
+            if (st->inverse)
+                phase *= -1;
+            kf_cexp(st->twiddles+i, phase );
+        }
+
+        kf_factor(nfft,st->factors);
+    }
+    return st;
+}
+
+
+void kiss_fft_stride(kiss_fft_cfg st,const kiss_fft_cpx *fin,kiss_fft_cpx *fout,int in_stride)
+{
+    if (fin == fout) {
+        //NOTE: this is not really an in-place FFT algorithm.
+        //It just performs an out-of-place FFT into a temp buffer
+        kiss_fft_cpx * tmpbuf = (kiss_fft_cpx*)KISS_FFT_TMP_ALLOC( sizeof(kiss_fft_cpx)*st->nfft);
+        kf_work(tmpbuf,fin,1,in_stride, st->factors,st);
+        memcpy(fout,tmpbuf,sizeof(kiss_fft_cpx)*st->nfft);
+        KISS_FFT_TMP_FREE(tmpbuf);
+    }else{
+        kf_work( fout, fin, 1,in_stride, st->factors,st );
+    }
+}
+
+void kiss_fft(kiss_fft_cfg cfg,const kiss_fft_cpx *fin,kiss_fft_cpx *fout)
+{
+    kiss_fft_stride(cfg,fin,fout,1);
+}
+
+
+void kiss_fft_cleanup(void)
+{
+    // nothing needed any more
+}
+
+int kiss_fft_next_fast_size(int n)
+{
+    while(1) {
+        int m=n;
+        while ( (m%2) == 0 ) m/=2;
+        while ( (m%3) == 0 ) m/=3;
+        while ( (m%5) == 0 ) m/=5;
+        if (m<=1)
+            break; /* n is completely factorable by twos, threes, and fives */
+        n++;
+    }
+    return n;
+}
diff --git a/xbmc/contrib/kissfft/kiss_fft.h b/xbmc/contrib/kissfft/kiss_fft.h
new file mode 100644
index 0000000..64c50f4
--- /dev/null
+++ b/xbmc/contrib/kissfft/kiss_fft.h
@@ -0,0 +1,124 @@
+#ifndef KISS_FFT_H
+#define KISS_FFT_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include <string.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ ATTENTION!
+ If you would like a :
+ -- a utility that will handle the caching of fft objects
+ -- real-only (no imaginary time component ) FFT
+ -- a multi-dimensional FFT
+ -- a command-line utility to perform ffts
+ -- a command-line utility to perform fast-convolution filtering
+
+ Then see kfc.h kiss_fftr.h kiss_fftnd.h fftutil.c kiss_fastfir.c
+  in the tools/ directory.
+*/
+
+#ifdef USE_SIMD
+# include <xmmintrin.h>
+# define kiss_fft_scalar __m128
+#define KISS_FFT_MALLOC(nbytes) _mm_malloc(nbytes,16)
+#define KISS_FFT_FREE _mm_free
+#else	
+#define KISS_FFT_MALLOC malloc
+#define KISS_FFT_FREE free
+#endif	
+
+
+#ifdef FIXED_POINT
+#include <sys/types.h>	
+# if (FIXED_POINT == 32)
+#  define kiss_fft_scalar int32_t
+# else	
+#  define kiss_fft_scalar int16_t
+# endif
+#else
+# ifndef kiss_fft_scalar
+/*  default is float */
+#   define kiss_fft_scalar float
+# endif
+#endif
+
+typedef struct {
+    kiss_fft_scalar r;
+    kiss_fft_scalar i;
+}kiss_fft_cpx;
+
+typedef struct kiss_fft_state* kiss_fft_cfg;
+
+/* 
+ *  kiss_fft_alloc
+ *  
+ *  Initialize a FFT (or IFFT) algorithm's cfg/state buffer.
+ *
+ *  typical usage:      kiss_fft_cfg mycfg=kiss_fft_alloc(1024,0,NULL,NULL);
+ *
+ *  The return value from fft_alloc is a cfg buffer used internally
+ *  by the fft routine or NULL.
+ *
+ *  If lenmem is NULL, then kiss_fft_alloc will allocate a cfg buffer using malloc.
+ *  The returned value should be free()d when done to avoid memory leaks.
+ *  
+ *  The state can be placed in a user supplied buffer 'mem':
+ *  If lenmem is not NULL and mem is not NULL and *lenmem is large enough,
+ *      then the function places the cfg in mem and the size used in *lenmem
+ *      and returns mem.
+ *  
+ *  If lenmem is not NULL and ( mem is NULL or *lenmem is not large enough),
+ *      then the function returns NULL and places the minimum cfg 
+ *      buffer size in *lenmem.
+ * */
+
+kiss_fft_cfg kiss_fft_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem); 
+
+/*
+ * kiss_fft(cfg,in_out_buf)
+ *
+ * Perform an FFT on a complex input buffer.
+ * for a forward FFT,
+ * fin should be  f[0] , f[1] , ... ,f[nfft-1]
+ * fout will be   F[0] , F[1] , ... ,F[nfft-1]
+ * Note that each element is complex and can be accessed like
+    f[k].r and f[k].i
+ * */
+void kiss_fft(kiss_fft_cfg cfg,const kiss_fft_cpx *fin,kiss_fft_cpx *fout);
+
+/*
+ A more generic version of the above function. It reads its input from every Nth sample.
+ * */
+void kiss_fft_stride(kiss_fft_cfg cfg,const kiss_fft_cpx *fin,kiss_fft_cpx *fout,int fin_stride);
+
+/* If kiss_fft_alloc allocated a buffer, it is one contiguous 
+   buffer and can be simply free()d when no longer needed*/
+#define kiss_fft_free free
+
+/*
+ Cleans up some memory that gets managed internally. Not necessary to call, but it might clean up 
+ your compiler output to call this before you exit.
+*/
+void kiss_fft_cleanup(void);
+	
+
+/*
+ * Returns the smallest integer k, such that k>=n and k has only "fast" factors (2,3,5)
+ */
+int kiss_fft_next_fast_size(int n);
+
+/* for real ffts, we need an even size */
+#define kiss_fftr_next_fast_size_real(n) \
+        (kiss_fft_next_fast_size( ((n)+1)>>1)<<1)
+
+#ifdef __cplusplus
+} 
+#endif
+
+#endif
diff --git a/xbmc/contrib/kissfft/kiss_fftr.c b/xbmc/contrib/kissfft/kiss_fftr.c
new file mode 100644
index 0000000..b8e238b
--- /dev/null
+++ b/xbmc/contrib/kissfft/kiss_fftr.c
@@ -0,0 +1,159 @@
+/*
+Copyright (c) 2003-2004, Mark Borgerding
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "kiss_fftr.h"
+#include "_kiss_fft_guts.h"
+
+struct kiss_fftr_state{
+    kiss_fft_cfg substate;
+    kiss_fft_cpx * tmpbuf;
+    kiss_fft_cpx * super_twiddles;
+#ifdef USE_SIMD
+    void * pad;
+#endif
+};
+
+kiss_fftr_cfg kiss_fftr_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem)
+{
+    int i;
+    kiss_fftr_cfg st = NULL;
+    size_t subsize, memneeded;
+
+    if (nfft & 1) {
+        fprintf(stderr,"Real FFT optimization must be even.\n");
+        return NULL;
+    }
+    nfft >>= 1;
+
+    kiss_fft_alloc (nfft, inverse_fft, NULL, &subsize);
+    memneeded = sizeof(struct kiss_fftr_state) + subsize + sizeof(kiss_fft_cpx) * ( nfft * 3 / 2);
+
+    if (lenmem == NULL) {
+        st = (kiss_fftr_cfg) KISS_FFT_MALLOC (memneeded);
+    } else {
+        if (*lenmem >= memneeded)
+            st = (kiss_fftr_cfg) mem;
+        *lenmem = memneeded;
+    }
+    if (!st)
+        return NULL;
+
+    st->substate = (kiss_fft_cfg) (st + 1); /*just beyond kiss_fftr_state struct */
+    st->tmpbuf = (kiss_fft_cpx *) (((char *) st->substate) + subsize);
+    st->super_twiddles = st->tmpbuf + nfft;
+    kiss_fft_alloc(nfft, inverse_fft, st->substate, &subsize);
+
+    for (i = 0; i < nfft/2; ++i) {
+        double phase =
+            -3.14159265358979323846264338327 * ((double) (i+1) / nfft + .5);
+        if (inverse_fft)
+            phase *= -1;
+        kf_cexp (st->super_twiddles+i,phase);
+    }
+    return st;
+}
+
+void kiss_fftr(kiss_fftr_cfg st,const kiss_fft_scalar *timedata,kiss_fft_cpx *freqdata)
+{
+    /* input buffer timedata is stored row-wise */
+    int k,ncfft;
+    kiss_fft_cpx fpnk,fpk,f1k,f2k,tw,tdc;
+
+    if ( st->substate->inverse) {
+        fprintf(stderr,"kiss fft usage error: improper alloc\n");
+        exit(1);
+    }
+
+    ncfft = st->substate->nfft;
+
+    /*perform the parallel fft of two real signals packed in real,imag*/
+    kiss_fft( st->substate , (const kiss_fft_cpx*)timedata, st->tmpbuf );
+    /* The real part of the DC element of the frequency spectrum in st->tmpbuf
+     * contains the sum of the even-numbered elements of the input time sequence
+     * The imag part is the sum of the odd-numbered elements
+     *
+     * The sum of tdc.r and tdc.i is the sum of the input time sequence. 
+     *      yielding DC of input time sequence
+     * The difference of tdc.r - tdc.i is the sum of the input (dot product) [1,-1,1,-1... 
+     *      yielding Nyquist bin of input time sequence
+     */
+ 
+    tdc.r = st->tmpbuf[0].r;
+    tdc.i = st->tmpbuf[0].i;
+    C_FIXDIV(tdc,2);
+    CHECK_OVERFLOW_OP(tdc.r ,+, tdc.i);
+    CHECK_OVERFLOW_OP(tdc.r ,-, tdc.i);
+    freqdata[0].r = tdc.r + tdc.i;
+    freqdata[ncfft].r = tdc.r - tdc.i;
+#ifdef USE_SIMD    
+    freqdata[ncfft].i = freqdata[0].i = _mm_set1_ps(0);
+#else
+    freqdata[ncfft].i = freqdata[0].i = 0;
+#endif
+
+    for ( k=1;k <= ncfft/2 ; ++k ) {
+        fpk    = st->tmpbuf[k]; 
+        fpnk.r =   st->tmpbuf[ncfft-k].r;
+        fpnk.i = - st->tmpbuf[ncfft-k].i;
+        C_FIXDIV(fpk,2);
+        C_FIXDIV(fpnk,2);
+
+        C_ADD( f1k, fpk , fpnk );
+        C_SUB( f2k, fpk , fpnk );
+        C_MUL( tw , f2k , st->super_twiddles[k-1]);
+
+        freqdata[k].r = HALF_OF(f1k.r + tw.r);
+        freqdata[k].i = HALF_OF(f1k.i + tw.i);
+        freqdata[ncfft-k].r = HALF_OF(f1k.r - tw.r);
+        freqdata[ncfft-k].i = HALF_OF(tw.i - f1k.i);
+    }
+}
+
+void kiss_fftri(kiss_fftr_cfg st,const kiss_fft_cpx *freqdata,kiss_fft_scalar *timedata)
+{
+    /* input buffer timedata is stored row-wise */
+    int k, ncfft;
+
+    if (st->substate->inverse == 0) {
+        fprintf (stderr, "kiss fft usage error: improper alloc\n");
+        exit (1);
+    }
+
+    ncfft = st->substate->nfft;
+
+    st->tmpbuf[0].r = freqdata[0].r + freqdata[ncfft].r;
+    st->tmpbuf[0].i = freqdata[0].r - freqdata[ncfft].r;
+    C_FIXDIV(st->tmpbuf[0],2);
+
+    for (k = 1; k <= ncfft / 2; ++k) {
+        kiss_fft_cpx fk, fnkc, fek, fok, tmp;
+        fk = freqdata[k];
+        fnkc.r = freqdata[ncfft - k].r;
+        fnkc.i = -freqdata[ncfft - k].i;
+        C_FIXDIV( fk , 2 );
+        C_FIXDIV( fnkc , 2 );
+
+        C_ADD (fek, fk, fnkc);
+        C_SUB (tmp, fk, fnkc);
+        C_MUL (fok, tmp, st->super_twiddles[k-1]);
+        C_ADD (st->tmpbuf[k],     fek, fok);
+        C_SUB (st->tmpbuf[ncfft - k], fek, fok);
+#ifdef USE_SIMD        
+        st->tmpbuf[ncfft - k].i *= _mm_set1_ps(-1.0);
+#else
+        st->tmpbuf[ncfft - k].i *= -1;
+#endif
+    }
+    kiss_fft (st->substate, st->tmpbuf, (kiss_fft_cpx *) timedata);
+}
diff --git a/xbmc/contrib/kissfft/kiss_fftr.h b/xbmc/contrib/kissfft/kiss_fftr.h
new file mode 100644
index 0000000..72e5a57
--- /dev/null
+++ b/xbmc/contrib/kissfft/kiss_fftr.h
@@ -0,0 +1,46 @@
+#ifndef KISS_FTR_H
+#define KISS_FTR_H
+
+#include "kiss_fft.h"
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    
+/* 
+ 
+ Real optimized version can save about 45% cpu time vs. complex fft of a real seq.
+
+ 
+ 
+ */
+
+typedef struct kiss_fftr_state *kiss_fftr_cfg;
+
+
+kiss_fftr_cfg kiss_fftr_alloc(int nfft,int inverse_fft,void * mem, size_t * lenmem);
+/*
+ nfft must be even
+
+ If you don't care to allocate space, use mem = lenmem = NULL 
+*/
+
+
+void kiss_fftr(kiss_fftr_cfg cfg,const kiss_fft_scalar *timedata,kiss_fft_cpx *freqdata);
+/*
+ input timedata has nfft scalar points
+ output freqdata has nfft/2+1 complex points
+*/
+
+void kiss_fftri(kiss_fftr_cfg cfg,const kiss_fft_cpx *freqdata,kiss_fft_scalar *timedata);
+/*
+ input freqdata has  nfft/2+1 complex points
+ output timedata has nfft scalar points
+*/
+
+#define kiss_fftr_free free
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/xbmc/utils/Makefile.in b/xbmc/utils/Makefile.in
index 011c98c..438f025 100644
--- a/xbmc/utils/Makefile.in
+++ b/xbmc/utils/Makefile.in
@@ -22,7 +22,6 @@ SRCS += fastmemcpy-arm.S
 SRCS += FileOperationJob.cpp
 SRCS += FileUtils.cpp
 SRCS += fstrcmp.c
-SRCS += fft.cpp
 SRCS += GLUtils.cpp
 SRCS += GroupUtils.cpp
 SRCS += HTMLUtil.cpp
@@ -49,6 +48,7 @@ SRCS += POUtils.cpp
 SRCS += ProgressJob.cpp
 SRCS += RecentlyAddedJob.cpp
 SRCS += RegExp.cpp
+SRCS += rfft.cpp
 SRCS += RingBuffer.cpp
 SRCS += RssManager.cpp
 SRCS += RssReader.cpp
diff --git a/xbmc/utils/fft.cpp b/xbmc/utils/fft.cpp
deleted file mode 100644
index 8f0ddab..0000000
--- a/xbmc/utils/fft.cpp
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- *                            COPYRIGHT
- *
- *  XAnalyser, frequence spectrum analyser for X Window
- *  Copyright (C) 1998 Arvin Schnell
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- *  Contact addresses:
- *  arvin@informatik.uni-bremen.de
- *  Arvin Schnell, Am Heidberg 8, 28865 Lilienthal, Germany
- *
- */
-
-
-#include <math.h>
-#include <algorithm>
-#include "fft.h"
-
-#ifndef M_PI
-#define M_PI  3.1415926535897932384626433832795
-#endif
-
-#ifndef M_SQRT2
-#define M_SQRT2 1.4142135623730950488016887242097
-#endif
-
-// WARNING:
-// Whenever you call that method directly, make sure
-// that you pass in ptr - 1. Also remember this method 
-// has a complex result. You most likely want to have a 
-// realfft only instead
-void fft( float data[], int nn, int isign )
-{
-  int n = nn << 1;
-  int i, j, m;
-
-  /* bit reversal section */
-
-  j = 1;
-  for ( i = 1; i < n; i += 2 )
-  {
-    if ( j > i )
-    {
-      std::swap( data[j], data[i] );
-      std::swap( data[j + 1], data[i + 1] );
-    }
-    m = nn;
-    while ( m >= 2 && j > m )
-    {
-      j -= m;
-      m >>= 1;
-    }
-    j += m;
-  }
-
-  /* Daniel-Lanczos section */
-
-  long double theta, wr, wpr, wpi, wi, wtemp;
-  float tempr, tempi;
-  int mmax = 2;
-  while (n > mmax)
-  {
-    int istep = mmax << 1;
-    theta = isign * ( 2.0 * M_PI / mmax );
-    wtemp = sin(0.5 * theta);
-    wpr = -2.0 * wtemp * wtemp;
-    wpi = sin( theta );
-    wr = 1.0;
-    wi = 0.0;
-    for ( m = 1; m < mmax; m += 2 )
-    {
-      for ( i = m; i <= n; i += istep )
-      {
-        j = i + mmax;
-        if (j >= n || i >= n)
-          break;
-        tempr = (float) (wr * data[j] - wi * data[j + 1]);
-        tempi = (float) (wr * data[j + 1] + wi * data[j]);
-        data[j] = data[i] - tempr;
-        data[j + 1] = data[i + 1] - tempi;
-        data[i] += tempr;
-        data[i + 1] += tempi;
-      }
-      wr = (wtemp = wr) * wpr - wi * wpi + wr;
-      wi = wi * wpr + wtemp * wpi + wi;
-    }
-    mmax = istep;
-  }
-}
-
-// By JM - packed 2 channel real fft - returns the amplitudes of the fft array
-// data[] is a 2n size array, with interleaved channels, and the fft is returned in data[]
-// interleaving is preserved.
-void twochannelrfft(float data[], int n)
-{
-  float rep, rem, aip, aim;
-  int nn = n + n;
-  int nn1 = nn + 1;
-  // data is already packed - do the transform
-  fft( data - 1, n , + 1 );
-
-  // now repack the array as needed
-  data[0] = data[0] * data[0]; // only need the amplitude squared
-  data[1] = data[1] * data[1];
-  data[n] = data[n] * data[n];
-  data[n + 1] = data[n + 1] * data[n + 1];
-  // don't need the last component - this is the constant component?
-
-  for (int j = 2; j < n; j += 2)
-  {
-    rep = (float)(0.5 * (data[j] + data[nn - j]));
-    rem = (float)(0.5 * (data[j] - data[nn - j]));
-    aip = (float)(0.5 * (data[j + 1] + data[nn1 - j]));
-    aim = (float)(0.5 * (data[j + 1] - data[nn1 - j]));
-    /* this works out the complex FT
-    fft1[j]=rep;
-    fft1[j+1]=aim;
-    fft1[nn-j]=rep;
-    fft1[nn1-j]=-aim;
-    fft2[j]=aip;
-    fft2[j+1]=-rem;
-    fft2[nn-j]=aip;
-    fft2[nn1-j]=rem; */ 
-    // we just need the amplitudes
-    data[j] = (float)(2 * (sqr(rep) + sqr(aim))); // was sqrt'd
-    data[j + 1] = (float)(2 * (sqr(rem) + sqr(aip)));
-  }
-}
-
-void twochanwithwindow(float data[], int n)
-{
-  float rep, rem, aip, aim;
-  int nn = n + n;
-  int nn1 = nn + 1;
-  // window the data
-  float wn;
-  for (int i = 0; i < nn; i += 2)
-  {
-    wn = (float)(0.5 * (1 - cos(M_PI * i / n)));
-    data[i] *= wn;
-    data[i + 1] *= wn;
-  }
-  // data is already packed - do the transform
-  fft( data - 1, n , + 1 );
-
-  // now repack the array as needed
-  data[0] = data[0] * data[0]; // only need the amplitude squared
-  data[1] = data[1] * data[1];
-  data[n] = data[n] * data[n];
-  data[n + 1] = data[n + 1] * data[n + 1];
-  // don't need the last component - this is the constant component?
-
-  for (int j = 2; j < n; j += 2)
-  {
-    rep = data[j] + data[nn - j];
-    rem = data[j] - data[nn - j];
-    aip = data[j + 1] + data[nn1 - j];
-    aim = data[j + 1] - data[nn1 - j];
-    data[j] = (float)(0.5 * (sqr(rep) + sqr(aim)));
-    data[j + 1] = (float)(0.5 * (sqr(rem) + sqr(aip)));
-  }
-}
-
diff --git a/xbmc/utils/fft.h b/xbmc/utils/fft.h
deleted file mode 100644
index 8a78aa7..0000000
--- a/xbmc/utils/fft.h
+++ /dev/null
@@ -1,52 +0,0 @@
-#ifndef fft_hh
-#define fft_hh
-/*
- *                            COPYRIGHT
- *
- *  XAnalyser, frequence spectrum analyser for X Window
- *  Copyright (C) 1998 Arvin Schnell
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- *  Contact addresses:
- *  arvin@informatik.uni-bremen.de
- *  Arvin Schnell, Am Heidberg 8, 28865 Lilienthal, Germany
- *
- */
-static __inline long double sqr( long double arg )
-{
-  return arg * arg;
-}
-
-
-static __inline void swap( float &a, float &b )
-{
-  float t = a; a = b; b = t;
-}
-
-// (complex) fast fourier transformation
-// Based on four1() in Numerical Recipes in C, Page 507-508.
-
-// The input in data[1..2*nn] is replaced by its fft or inverse fft, depending
-// only on isign (+1 for fft, -1 for inverse fft). The number of complex numbers
-// n must be a power of 2 (which is not checked).
-
-void fft( float data[], int nn, int isign );
-
-void twochannelrfft(float data[], int n);
-void twochanwithwindow(float data[], int n); // test
-
-
-#endif
diff --git a/xbmc/utils/rfft.cpp b/xbmc/utils/rfft.cpp
new file mode 100644
index 0000000..f2e6a25
--- /dev/null
+++ b/xbmc/utils/rfft.cpp
@@ -0,0 +1,75 @@
+/*
+ *      Copyright (C) 2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "rfft.h"
+
+#if defined(TARGET_WINDOWS) && !defined(_USE_MATH_DEFINES)
+#define _USE_MATH_DEFINES
+#endif
+#include <math.h>
+
+RFFT::RFFT(int size, bool windowed) :
+  m_size(size), m_windowed(windowed)
+{
+  m_cfg = kiss_fftr_alloc(m_size,0,nullptr,nullptr);
+}
+
+void RFFT::calc(const float* input, float* output)
+{
+  // temporary buffers
+  std::vector<kiss_fft_scalar> linput(m_size), rinput(m_size);
+  std::vector<kiss_fft_cpx> loutput(m_size), routput(m_size);
+
+  for (size_t i=0;i<m_size;++i)
+  {
+    linput[i] = input[2*i];
+    rinput[i] = input[2*i+1];
+  }
+
+  if (m_windowed)
+  {
+    hann(linput);
+    hann(rinput);
+  }
+
+  // transform channels
+  kiss_fftr(m_cfg, &linput[0], &loutput[0]);
+  kiss_fftr(m_cfg, &rinput[0], &routput[0]);
+
+  auto&& filter = [&](kiss_fft_cpx& data)
+  {
+    return sqrt(data.r*data.r+data.i*data.i) * 2.0/m_size * (m_windowed?sqrt(8.0/3.0):1.0);
+  };
+
+  // interleave while taking magnitudes and normalizing
+  for (size_t i=0;i<m_size/2;++i)
+  {
+    output[2*i] = filter(loutput[i]);
+    output[2*i+1] = filter(routput[i]);
+  }
+}
+
+#include <iostream>
+
+void RFFT::hann(std::vector<kiss_fft_scalar>& data)
+{
+  for (size_t i=0;i<data.size();++i)
+    data[i] *= 0.5*(1.0-cos(2*M_PI*i/(data.size()-1)));
+}
diff --git a/xbmc/utils/rfft.h b/xbmc/utils/rfft.h
new file mode 100644
index 0000000..2241024
--- /dev/null
+++ b/xbmc/utils/rfft.h
@@ -0,0 +1,46 @@
+#pragma once
+/*
+ *      Copyright (C) 2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "contrib/kissfft/kiss_fftr.h"
+#include <vector>
+
+//! \brief Class performing a RFFT of interleaved stereo data.
+class RFFT
+{
+public:
+  //! \brief The constructor creates a RFFT plan.
+  //! \brief size Length of time data for a single channel.
+  //! \brief windowed Whether or not to apply a Hann window to data.
+  RFFT(int size, bool windowed=false);
+
+  //! \brief Calculate FFTs
+  //! \param input Input data of size 2*m_size
+  //! \param output Output data of size m_size.
+  void calc(const float* input, float* output);
+protected:
+  //! \brief Apply a Hann window to a buffer.
+  //! \param data Vector with data to apply window to.
+  static void hann(std::vector<kiss_fft_scalar>& data);
+
+  size_t m_size;       //!< Size for a single channel.
+  bool m_windowed;     //!< Whether or not a Hann window is applied.
+  kiss_fftr_cfg m_cfg; //!< FFT plan
+};
diff --git a/xbmc/utils/test/Makefile b/xbmc/utils/test/Makefile
index 31ae778..8fa0526 100644
--- a/xbmc/utils/test/Makefile
+++ b/xbmc/utils/test/Makefile
@@ -12,7 +12,6 @@ SRCS=	\
 	TestDatabaseUtils.cpp \
 	TestEndianSwap.cpp \
 	Testfastmemcpy.cpp \
-	Testfft.cpp \
 	TestFileOperationJob.cpp \
 	TestFileUtils.cpp \
 	Testfstrcmp.cpp \
@@ -35,6 +34,7 @@ SRCS=	\
 	TestPerformanceSample.cpp \
 	TestPOUtils.cpp \
 	TestRegExp.cpp \
+        Testrfft.cpp \
 	TestRingBuffer.cpp \
 	TestScraperParser.cpp \
 	TestScraperUrl.cpp \
diff --git a/xbmc/utils/test/Testfft.cpp b/xbmc/utils/test/Testfft.cpp
deleted file mode 100644
index f4260a8..0000000
--- a/xbmc/utils/test/Testfft.cpp
+++ /dev/null
@@ -1,300 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "utils/fft.h"
-#include "utils/StringUtils.h"
-
-#include "gtest/gtest.h"
-
-/* refdata[] below was generated using the following Python script.
-
-import math
-import wave
-import struct
-import sys
-
-if __name__=='__main__':
-    # http://stackoverflow.com/questions/3637350/how-to-write-stereo-wav-files-in-python
-    # http://www.sonicspot.com/guide/wavefiles.html
-    freq=440.0
-    data_size=128
-    fname="test.wav"
-    frate=11025.0
-    amp=64000.0
-    nchannels=1
-    sampwidth=2
-    framerate=int(frate)
-    nframes=data_size
-    comptype="NONE"
-    compname="not compressed"
-    data=[math.sin(2*math.pi*freq*(x/frate))
-          for x in range(data_size)]
-    count = 0
-    sys.stdout.write("static const float refdata[] = {\n")
-    for v in data:
-      sys.stdout.write(str(v) + "f,")
-      count += 1
-      if count % 4 == 0:
-        sys.stdout.write("\n")
-      else:
-        sys.stdout.write(" ")
-    sys.stdout.write("};\n")
-*/
-
-static const float refdata[] = {
-0.0f, 0.248137847944f, 0.480754541017f, 0.683299780871f,
-0.843104254616f, 0.950172107096f, 0.997806186976f, 0.983026957126f,
-0.906758866265f, 0.773772524197f, 0.592386297618f, 0.373945991846f,
-0.132115164631f, -0.117979536667f, -0.360694554958f, -0.580847936259f,
--0.764668969029f, -0.900659549526f, -0.980313394334f, -0.998648112931f,
--0.954516858881f, -0.850680065687f, -0.693632780202f, -0.493198393981f,
--0.261914184895f, -0.0142471037071f, 0.234311141425f, 0.46821309956f,
-0.672828078337f, 0.835357301588f, 0.945634479622f, 0.996761716077f,
-0.985540975016f, 0.912674119782f, 0.782719011074f, 0.603804410325f,
-0.387121521337f, 0.146223974503f, -0.103819960006f, -0.347369900587f,
--0.569191668423f, -0.755410193505f, -0.894377407666f, -0.977400837465f,
--0.999287323041f, -0.958667853037f, -0.858083196987f, -0.703824978831f,
--0.505542132473f, -0.275637355817f, -0.0284913153908f, 0.220436872025f,
-0.455576615403f, 0.662219798253f, 0.827440779159f, 0.940904897555f,
-0.995514912254f, 0.987854937681f, 0.918404109336f, 0.791506613611f,
-0.615099956615f, 0.400218468928f, 0.160303102331f, -0.0896393089034f,
--0.333974733507f, -0.557419860219f, -0.745998077066f, -0.887913715899f,
--0.974289877741f, -0.999723687553f, -0.96262424695f, -0.865312145751f,
--0.71387430784f, -0.517783250833f, -0.289304575039f, -0.0427297436149f,
-0.206517856086f, 0.442847653627f, 0.651477093995f, 0.819356294308f,
-0.935984320952f, 0.994066028594f, 0.989968375411f, 0.923947671797f,
-0.800133548011f, 0.626270643602f, 0.413234176067f, 0.17434969019f,
--0.0754404618937f, -0.320511772808f, -0.545534901211f, -0.736434530278f,
--0.881269786291f, -0.970981146657f, -0.999957117888f, -0.966385237512f,
--0.872365444572f, -0.723778727314f, -0.529919264233f, -0.302913068248f,
--0.056959498117f, 0.192556919032f, 0.430028798089f, 0.64060214623f,
-0.811105488104f, 0.930873748644f, 0.992415359208f, 0.991880859198f,
-0.929303681875f, 0.80859806309f, 0.637314203745f, 0.42616600069f,
-0.188360886759f, -0.0612263012046f, -0.306983751339f, -0.533539203927f,
--0.72672149445f, -0.874446967495f, -0.967475315852f, -0.999987566662f,
--0.969950061278f, -0.879241661701f, -0.733536226752f, -0.541947709182f,
--0.316460073053f, -0.0711776903954f, 0.178556894799f, 0.417122650891f
-};
-
-#define REFDATA_NUMELEMENTS 128 /*(sizeof(refdata)/sizeof(float))*/
-
-/* All reference data below were generated by using the following C++ code.
-
-  fprintf(stdout, "static const float reffftdata[] = {\n");
-  for (i = 0; i < REFDATA_NUMELEMENTS; i++)
-  {
-    fprintf(stdout, "%.6ff,", vardata[i]);
-    if ((i + 1) % 4 == 0)
-      fprintf(stdout, "\n");
-    else
-      fprintf(stdout, " ");
-  }
-  fprintf(stdout, "};\n");
-
-*/
-
-static const float reffftdata[] = {
-0.000000f, 0.449505f, 0.120648f, 0.233138f,
-0.392939f, 0.043552f, 0.833054f, -0.148657f,
-1.675773f, -0.424927f, 3.999525f, -3.602860f,
-48.666092f, 0.123507f, -6.779173f, -0.179830f,
--3.556417f, -0.323241f, -2.528245f, -0.424007f,
--1.999831f, -0.503748f, -1.662579f, -0.569499f,
--1.417722f, -0.624251f, -1.224108f, -0.669501f,
--1.061725f, -0.706093f, -0.919814f, -0.734565f,
--0.792209f, -0.755297f, -0.675225f, -0.768604f,
--0.566617f, -0.774772f, -0.465016f, -0.774090f,
--0.369611f, -0.766866f, -0.279953f, -0.753430f,
--0.195832f, -0.734147f, -0.117191f, -0.709420f,
--0.044083f, -0.679685f, 0.023383f, -0.645416f,
-0.085060f, -0.607121f, 0.140793f, -0.565342f,
-0.190426f, -0.520648f, 0.233821f, -0.473637f,
-0.270868f, -0.424926f, 0.301492f, -0.375151f,
-0.325655f, -0.324962f, 0.343369f, -0.275019f,
-0.354691f, -0.225984f, 0.359731f, -0.178525f,
-0.358652f, -0.133307f, 0.351671f, -0.090984f,
-0.339060f, -0.052212f, 0.321141f, -0.017629f,
-0.298293f, 0.012125f, 0.270944f, 0.036423f,
-0.239573f, 0.054633f, 0.204705f, 0.066113f,
-0.166914f, 0.070200f, 0.126814f, 0.066174f,
-0.085068f, 0.053236f, 0.042377f, 0.030439f,
--0.000509f, -0.003392f, -0.042792f, -0.049815f,
--0.083613f, -0.111011f, -0.122037f, -0.190212f,
--0.157020f, -0.292521f, -0.187344f, -0.426526f,
--0.211503f, -0.607937f, -0.227426f, -0.868800f,
--0.231823f, -1.285804f, -0.218194f, -2.098434f,
--0.168627f, -4.622009f, 0.009162f, 38.381283f,
--2.935104f, 3.676884f, -0.513415f, 1.829207f,
--0.334315f, 1.124193f, -0.207913f, 0.725023f,
-};
-
-static const float reffftinversedata[] = {
-0.000000f, 0.449505f, 0.120648f, 0.725023f,
--0.066419f, 1.124193f, -0.207913f, 1.829207f,
--0.334315f, 3.676884f, -0.513415f, 38.381283f,
--2.935104f, -4.622009f, 0.009162f, -2.098434f,
--0.168627f, -1.285804f, -0.218194f, -0.868800f,
--0.231823f, -0.607937f, -0.227426f, -0.426526f,
--0.211503f, -0.292521f, -0.187344f, -0.190212f,
--0.157020f, -0.111011f, -0.122037f, -0.049815f,
--0.083613f, -0.003392f, -0.042792f, 0.030439f,
--0.000509f, 0.053236f, 0.042377f, 0.066174f,
-0.085068f, 0.070200f, 0.126814f, 0.066113f,
-0.166914f, 0.054633f, 0.204705f, 0.036423f,
-0.239573f, 0.012125f, 0.270944f, -0.017629f,
-0.298293f, -0.052212f, 0.321141f, -0.090984f,
-0.339060f, -0.133307f, 0.351671f, -0.178525f,
-0.358652f, -0.225984f, 0.359731f, -0.275019f,
-0.354691f, -0.324962f, 0.343369f, -0.375151f,
-0.325655f, -0.424926f, 0.301492f, -0.473637f,
-0.270868f, -0.520648f, 0.233821f, -0.565342f,
-0.190426f, -0.607121f, 0.140793f, -0.645416f,
-0.085060f, -0.679685f, 0.023383f, -0.709420f,
--0.044083f, -0.734147f, -0.117191f, -0.753430f,
--0.195832f, -0.766866f, -0.279953f, -0.774090f,
--0.369611f, -0.774772f, -0.465016f, -0.768604f,
--0.566617f, -0.755297f, -0.675225f, -0.734565f,
--0.792209f, -0.706093f, -0.919814f, -0.669501f,
--1.061725f, -0.624251f, -1.224108f, -0.569499f,
--1.417722f, -0.503748f, -1.662579f, -0.424007f,
--1.999831f, -0.323241f, -2.528245f, -0.179830f,
--3.556417f, 0.123507f, -6.779173f, -3.602860f,
-48.666092f, -0.424927f, 3.999525f, -0.148657f,
-1.675773f, 0.043552f, 0.833054f, 0.233138f,
-};
-
-static const float reftwochannelrfftdata[] = {
-0.014556f, 0.202055f, 0.174283f, 0.564540f,
-0.779294f, 1.223621f, 2.855724f, 3.432353f,
-14.488905f, 15.470927f, 1926.995483f, 1936.110718f,
-34.176479f, 33.159004f, 8.778496f, 8.333804f,
-4.234725f, 3.962682f, 2.589059f, 2.398601f,
-1.791486f, 1.647755f, 1.337403f, 1.223514f,
-1.051121f, 0.957675f, 0.857526f, 0.778798f,
-0.719788f, 0.652054f, 0.617972f, 0.558680f,
-0.540455f, 0.487790f, 0.480051f, 0.432682f,
-0.432111f, 0.389031f, 0.393506f, 0.353940f,
-0.362065f, 0.325402f, 0.336244f, 0.301994f,
-0.314917f, 0.282679f, 0.297250f, 0.266693f,
-0.282615f, 0.253461f, 0.270538f, 0.242548f,
-0.260654f, 0.233622f, 0.252682f, 0.226430f,
-0.246418f, 0.220773f, 0.241694f, 0.216511f,
-0.238397f, 0.213538f, 0.236449f, 0.211782f,
-0.117902f, 0.105600f, -0.357960f, -0.308602f,
--0.372784f, -0.292395f, -0.387933f, -0.276250f,
--0.403502f, -0.260078f, -0.419604f, -0.243792f,
--0.436362f, -0.227290f, -0.453916f, -0.210478f,
--0.472433f, -0.193249f, -0.492110f, -0.175478f,
--0.513182f, -0.157028f, -0.535943f, -0.137741f,
--0.560756f, -0.117426f, -0.588082f, -0.095855f,
--0.618519f, -0.072741f, -0.652857f, -0.047725f,
--0.692169f, -0.020336f, -0.737947f, 0.010054f,
--0.792340f, 0.044317f, -0.858569f, 0.083711f,
--0.941691f, 0.130146f, -1.050159f, 0.186711f,
--1.199277f, 0.258840f, -1.419963f, 0.357229f,
--1.785721f, 0.506807f, -2.525070f, 0.783990f,
--4.890463f, 1.604234f, 36.070564f, -11.902861f,
-3.081995f, -0.935849f, 1.359818f, -0.300774f,
-0.721637f, -0.007045f, 0.368046f, 0.218320f,
-};
-
-static const float reftwochanwithwindowdata[] = {
-0.000078f, 0.000219f, 0.000856f, 0.001174f,
-0.007080f, 0.007566f, 0.107324f, 0.108530f,
-90.137039f, 90.161346f, 504.375732f, 504.333801f,
-173.107437f, 173.125870f, 0.244316f, 0.243784f,
-0.012957f, 0.012861f, 0.001967f, 0.001938f,
-0.000483f, 0.000471f, 0.000157f, 0.000152f,
-0.000062f, 0.000059f, 0.000028f, 0.000026f,
-0.000014f, 0.000013f, 0.000007f, 0.000007f,
-0.000004f, 0.000004f, 0.000003f, 0.000002f,
-0.000002f, 0.000001f, 0.000001f, 0.000001f,
-0.000001f, 0.000001f, 0.000000f, 0.000000f,
-0.000000f, 0.000000f, 0.000000f, 0.000000f,
-0.000000f, 0.000000f, 0.000000f, 0.000000f,
-0.000000f, 0.000000f, 0.000000f, 0.000000f,
-0.000000f, 0.000000f, 0.000000f, 0.000000f,
-0.000000f, 0.000000f, 0.000000f, 0.000000f,
-0.000000f, 0.000000f, 0.000058f, 0.000038f,
-0.000081f, 0.000016f, 0.000106f, -0.000007f,
-0.000133f, -0.000029f, 0.000164f, -0.000052f,
-0.000199f, -0.000077f, 0.000241f, -0.000105f,
-0.000290f, -0.000135f, 0.000349f, -0.000169f,
-0.000422f, -0.000210f, 0.000513f, -0.000257f,
-0.000628f, -0.000314f, 0.000778f, -0.000385f,
-0.000975f, -0.000475f, 0.001243f, -0.000593f,
-0.001616f, -0.000750f, 0.002154f, -0.000969f,
-0.002959f, -0.001283f, 0.004224f, -0.001760f,
-0.006336f, -0.002532f, 0.010161f, -0.003890f,
-0.017893f, -0.006565f, 0.036268f, -0.012797f,
-0.093398f, -0.031901f, 0.406511f, -0.135766f,
--10.831606f, 3.581835f, 18.487400f, -6.118526f,
--7.816598f, 2.582984f, -0.270999f, 0.085336f,
--0.071148f, 0.017091f, -0.026548f, -0.001455f,
-};
-
-TEST(Testfft, fft)
-{
-  int i;
-  float vardata[REFDATA_NUMELEMENTS];
-  float res;
-
-  memcpy(vardata, refdata, sizeof(refdata));
-  fft(vardata - 1, REFDATA_NUMELEMENTS/2, 1);
-  // let's see if it's okay enough
-  fft(vardata -1, REFDATA_NUMELEMENTS/2, -1);
-  for (i = 0; i < REFDATA_NUMELEMENTS; i++)
-  {
-    res =  vardata[i] / (REFDATA_NUMELEMENTS / 2);
-    EXPECT_NEAR(res, refdata[i], 0.000001);
-  }
-}
-
-TEST(Testfft, twochannelrfft)
-{
-  int i;
-  float vardata[REFDATA_NUMELEMENTS];
-  std::string refstr, varstr;
-
-  memcpy(vardata, refdata, sizeof(refdata));
-  twochannelrfft(vardata, REFDATA_NUMELEMENTS/2);
-  for (i = 0; i < REFDATA_NUMELEMENTS; i++)
-  {
-    refstr = StringUtils::Format("%.6f", reftwochannelrfftdata[i]);
-    varstr = StringUtils::Format("%.6f", vardata[i]);
-    EXPECT_STREQ(refstr.c_str(), varstr.c_str());
-  }
-}
-
-TEST(Testfft, twochanwithwindow)
-{
-  int i;
-  float vardata[REFDATA_NUMELEMENTS];
-  std::string refstr, varstr;
-
-  memcpy(vardata, refdata, sizeof(refdata));
-  twochanwithwindow(vardata, REFDATA_NUMELEMENTS/2);
-  for (i = 0; i < REFDATA_NUMELEMENTS; i++)
-  {
-    refstr = StringUtils::Format("%.6f", reftwochanwithwindowdata[i]);
-    varstr = StringUtils::Format("%.6f", vardata[i]);
-    EXPECT_STREQ(refstr.c_str(), varstr.c_str());
-  }
-}
diff --git a/xbmc/utils/test/Testrfft.cpp b/xbmc/utils/test/Testrfft.cpp
new file mode 100644
index 0000000..3b382e6
--- /dev/null
+++ b/xbmc/utils/test/Testrfft.cpp
@@ -0,0 +1,46 @@
+/*
+ *      Copyright (C) 2015 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "utils/rfft.h"
+
+#include "gtest/gtest.h"
+
+TEST(TestRFFT, SimpleSignal)
+{
+  const int size = 32;
+  const int freq1 = 5;
+  const int freq2[] = {1,7};
+  std::vector<float> input(2*size);
+  std::vector<float> output(size);
+  for (size_t i=0;i<size;++i)
+  {
+    input[2*i] = cos(freq1*2.0*M_PI*i/size);
+    input[2*i+1] = cos(freq2[0]*2.0*M_PI*i/size)+cos(freq2[1]*2.0*M_PI*i/size);
+  }
+  RFFT transform(size, false);
+
+  transform.calc(&input[0], &output[0]);
+
+  for (size_t i=0;i<size/2;++i)
+  {
+    EXPECT_NEAR(output[2*i],(i==freq1?1.0:0.0), 1e-7);
+    EXPECT_NEAR(output[2*i+1], ((i==freq2[0]||i==freq2[1])?1.0:0.0), 1e-7);
+  }
+}
